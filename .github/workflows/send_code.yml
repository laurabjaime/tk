name: Send Python Code to API

on:
  push:
    branches:
      - main  # Merge to main

jobs:
  send_code_to_api:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout the code
        uses: actions/checkout@v3

      - name: Debug - Check API Key
        run: |
          if [ -z "${{ secrets.API_KEY }}" ]; then
            echo "Error: API_KEY is missing from GitHub Secrets!"
            exit 1
          else
            echo "API_KEY is properly set!"
          fi

      - name: Read all Python files and store them as strings dynamically
        run: |
          echo "Searching for Python files..."

          # Lista todos os arquivos .py no reposit√≥rio
          PYTHON_FILES=$(find . -maxdepth 1 -type f -name "*.py" | xargs -n 1 basename | tr '\n' ' ')

          # Se nenhum arquivo .py for encontrado, exibe um erro e interrompe o workflow
          if [ -z "$PYTHON_FILES" ]; then
            echo "ERROR: No Python files found!"
            exit 1
          fi

          echo "Found Python files: $PYTHON_FILES"

          # Armazena os nomes dos arquivos em uma vari√°vel de ambiente
          echo "PYTHON_FILES=${PYTHON_FILES}" >> $GITHUB_ENV

          # Loop para ler e armazenar o conte√∫do de cada arquivo dinamicamente
          for file in $PYTHON_FILES; do
            FILE_NAME=$(basename "$file" .py | tr '[:lower:]' '[:upper:]')  # Remove .py e coloca em mai√∫sculas
            echo "üìÑ Processing file: $file ‚Üí Stored as ${FILE_NAME}_CODE"

            FILE_CONTENT=$(awk '{printf "%s\\n", $0}' "$file" | paste -sd '' | sed 's/\\\\n/\\n/g' | sed 's/\n/\\n/g')

            # Se o arquivo estiver vazio, exibe um aviso mas continua o workflow
            if [[ -z "$FILE_CONTENT" ]]; then
              echo "WARNING: File $file is empty!"
              continue  # Continua para o pr√≥ximo arquivo, sem interromper o workflow
            fi

            # Salva cada c√≥digo no ambiente do GitHub Actions com um nome din√¢mico
            echo "${FILE_NAME}_CODE=${FILE_CONTENT}" >> $GITHUB_ENV
          done

      - name: Send code to API dynamically
        env:
          API_KEY: ${{ secrets.API_KEY }}
          PYTHON_FILES: ${{ env.PYTHON_FILES }}
        run: |
          python - <<EOF
          import http.client
          import json
          import os

          # Configura√ß√£o da API
          API_HOST = "eu-central-1.taktile-org.decide.taktile.com"
          ENDPOINT_LIST_FLOWS = "/run/api/v1/flows/list-decision-graphs/sandbox/decide"
          ENDPOINT_GET_GRAPH = "/run/api/v1/flows/get-decision-graph/sandbox/decide"
          ENDPOINT_UPDATE = "/run/api/v1/flows/patch-decision-graph/sandbox/decide"

          api_key = os.getenv("API_KEY")
          if not api_key:
              raise ValueError("‚ùå ERROR: API_KEY is empty!")

          headers = {
              "X-Api-Key": api_key,
              "accept": "application/json",
              "Content-Type": "application/json"
          }

          # Criar conex√£o com a API
          conn = http.client.HTTPSConnection(API_HOST)

          def flow_ids(org_name):
              """Obt√©m todos os flow_id da organiza√ß√£o."""
              payload = json.dumps({
                  "data": {"organization_name": org_name},
                  "metadata": {"version": "v1.0", "entity_id": "string"},
                  "control": {"execution_mode": "sync"}
              })
              conn.request("POST", ENDPOINT_LIST_FLOWS, payload, headers)
              res = conn.getresponse()
              data = res.read()
              response_json = json.loads(data.decode("utf-8"))
              
              return [flow["flow_id"] for flow in response_json.get("data", {}).get("flows", [])]

          def node_ids(org_name):
              """Obt√©m todos os node_id dos code_nodes de cada flow."""
              flows = flow_ids(org_name)
              ans = {}
              for flow_id in flows:
                  payload = json.dumps({
                      "data": {"flow_id": flow_id},
                      "metadata": {"version": "v1.0", "entity_id": "string"},
                      "control": {"execution_mode": "sync"}
                  })
                  conn.request("POST", ENDPOINT_GET_GRAPH, payload, headers)
                  res = conn.getresponse()
                  data = res.read()
                  response_json = json.loads(data.decode("utf-8"))

                  for node in response_json.get("data", {}).get("graph", []):
                      if node.get("node_type") == "code_node":
                          node_name = node.get("node_name", "").lower()
                          node_id = node.get("node_id")
                          if node_name in ans:
                              ans[node_name].append((flow_id, node_id))
                          else:
                              ans[node_name] = [(flow_id, node_id)]
              return ans

          def get_name_to_id_mapping(org_name):
              """Relaciona os nomes dos arquivos aos seus respectivos flow_id e node_id."""
              return node_ids(org_name)

          # Organiza√ß√£o usada (pode ser parametrizado se necess√°rio)
          ORGANIZATION_NAME = "NNN"

          # Lista de arquivos detectados
          python_files = os.getenv("PYTHON_FILES", "").split()
          if not python_files:
              raise ValueError("‚ùå ERROR: No Python files found!")

          print(f"‚úÖ Found Python files: {python_files}")

          # Obter o mapeamento nome -> flow_id, node_id
          name_to_id_mapping = get_name_to_id_mapping(ORGANIZATION_NAME)
          print(f"üìå Mapping: {name_to_id_mapping}")

          # Enviar cada arquivo automaticamente
          for file_name in python_files:
              env_var = f"{file_name.replace('.py', '').upper()}_CODE"
              src_code = os.getenv(env_var)

              if not src_code or src_code.strip() == "":
                  print(f"‚ö†Ô∏è WARNING: No code found for {file_name}, skipping...")
                  continue

              node_name = file_name.replace(".py", "").lower()
              if node_name not in name_to_id_mapping:
                  print(f"‚ö†Ô∏è WARNING: No node_id found for {node_name}, skipping...")
                  continue

              # Usar o primeiro flow_id e node_id encontrados para o node_name
              flow_id, node_id = name_to_id_mapping[node_name][0]

              # Criar payload din√¢mico
              payload = json.dumps({
                  "data": {
                      "flow_id": flow_id,
                      "node_id": node_id,
                      "src_code": src_code
                  },
                  "metadata": {
                      "version": "v1.0",
                      "entity_id": "string"
                  },
                  "control": {
                      "execution_mode": "sync"
                  }
              })

              print(f"üöÄ Sending {file_name} (flow_id: {flow_id}, node_id: {node_id}) to API...")
              conn.request("POST", ENDPOINT_UPDATE, payload, headers)
              res = conn.getresponse()
              print(f"‚úÖ {file_name} response:", res.status, res.read().decode("utf-8"))

          print("üéØ All files processed!")
          EOF


