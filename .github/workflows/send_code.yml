name: Send Python Code to API

on:
  push:
    branches:
      - main  # Merge to main

jobs:
  send_code_to_api:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout the code
        uses: actions/checkout@v3

      - name: Debug - Check API Key
        run: |
          if [ -z "${{ secrets.API_KEY }}" ]; then
            echo "Error: API_KEY is missing from GitHub Secrets!"
            exit 1
          else
            echo "API_KEY is properly set!"
          fi

      - name: Read all Python files and store them as strings dynamically
        run: |
          echo "Searching for Python files..."

          # Lista todos os arquivos .py no repositório
          PYTHON_FILES=$(find . -maxdepth 1 -type f -name "*.py" | xargs -n 1 basename | tr '\n' ' ')

          # Se nenhum arquivo .py for encontrado, exibe um erro e interrompe o workflow
          if [ -z "$PYTHON_FILES" ]; then
            echo "ERROR: No Python files found!"
            exit 1
          fi

          echo "Found Python files: $PYTHON_FILES"

          # Armazena os nomes dos arquivos em uma variável de ambiente
          echo "PYTHON_FILES=${PYTHON_FILES}" >> $GITHUB_ENV

          # Loop para ler e armazenar o conteúdo de cada arquivo dinamicamente
          for file in $PYTHON_FILES; do
            FILE_NAME=$(basename "$file" .py | tr '[:lower:]' '[:upper:]')  # Remove .py e coloca em maiúsculas
            echo "📄 Processing file: $file → Stored as ${FILE_NAME}_CODE"

            FILE_CONTENT=$(awk '{printf "%s\\n", $0}' "$file" | paste -sd '' | sed 's/\\\\n/\\n/g' | sed 's/\n/\\n/g')

            # Se o arquivo estiver vazio, exibe um aviso mas continua o workflow
            if [[ -z "$FILE_CONTENT" ]]; then
              echo "WARNING: File $file is empty!"
              continue  # Continua para o próximo arquivo, sem interromper o workflow
            fi

            # Salva cada código no ambiente do GitHub Actions com um nome dinâmico
            echo "${FILE_NAME}_CODE=${FILE_CONTENT}" >> $GITHUB_ENV
          done

      - name: Send code to API
        env:
          API_KEY: ${{ secrets.API_KEY }}
          PYTHON_FILES: ${{ env.PYTHON_FILES }}
        run: |
          python - <<EOF
          import http.client
          import json
          import os

          # Configuração da API
          API_HOST = "eu-central-1.decide.com"
          ENDPOINT = "/run/api/v1/flows/patch-decision-graph/sandbox/decide"
          api_key = os.getenv("API_KEY")

          if not api_key:
              raise ValueError("❌ ERROR: API_KEY is empty!")

          headers = {
              "X-Api-Key": api_key,
              "accept": "application/json",
              "Content-Type": "application/json"
          }

          # Lista de arquivos detectados
          python_files = os.getenv("PYTHON_FILES", "").split()
          if not python_files:
              raise ValueError("❌ ERROR: No Python files found!")

          print(f"✅ Found Python files: {python_files}")

          # Criar conexão com a API
          conn = http.client.HTTPSConnection(API_HOST)

          # Enviar cada arquivo automaticamente
          for file_name in python_files:
              env_var = f"{file_name.replace('.py', '').upper()}_CODE"
              src_code = os.getenv(env_var)

              if not src_code or src_code.strip() == "":
                  print(f"⚠️ WARNING: No code found for {file_name}, skipping...")
                  continue

              # Criar payload dinâmico (Flow ID e Node ID são estáticos por enquanto)
              payload = json.dumps({
                  "data": {
                      "flow_id": "06457ab1-3367-43c3-9e6b-4dbaa88d1b1b",
                      "node_id": "affc68e2-f4e7-40b2-a8e4-4f08ac9cc123",
                      "src_code": src_code
                  },
                  "metadata": {
                      "version": "v1.0",
                      "entity_id": "string"
                  },
                  "control": {
                      "execution_mode": "sync"
                  }
              })

              print(f"🚀 Sending {file_name} to API...")
              conn.request("POST", ENDPOINT, payload, headers)
              res = conn.getresponse()
              print(f"✅ {file_name} response:", res.status, res.read().decode("utf-8"))

          print("🎯 All files processed!")
          EOF

