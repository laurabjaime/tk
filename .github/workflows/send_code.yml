name: Send Python Code to API

on:
  push:
    branches:
      - main  # Merge to main

jobs:
  send_code_to_api:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout the code
        uses: actions/checkout@v3

      - name: Debug - Check API Key
        run: |
          if [ -z "${{ secrets.API_KEY }}" ]; then
            echo "Error: API_KEY is missing from GitHub Secrets!"
            exit 1
          else
            echo "API_KEY is properly set!"
          fi

      - name: Read all Python files and store them as strings dynamically
        run: |
          echo "🔍 Searching for Python files..."

          # Lista todos os arquivos .py no repositório
          PYTHON_FILES=$(find . -maxdepth 1 -type f -name "*.py" | xargs -n 1 basename | tr '\n' ' ')

          # Se nenhum arquivo .py for encontrado, exibe um erro e interrompe o workflow
          if [ -z "$PYTHON_FILES" ]; then
            echo "❌ ERROR: No Python files found!"
            exit 1
          fi

          echo "✅ Found Python files: $PYTHON_FILES"

          # Armazena os nomes dos arquivos em uma variável de ambiente
          echo "PYTHON_FILES=${PYTHON_FILES}" >> $GITHUB_ENV

          # Loop para ler e armazenar o conteúdo de cada arquivo dinamicamente
          for file in $PYTHON_FILES; do
            FILE_NAME=$(basename "$file" .py | tr '[:lower:]' '[:upper:]')  # Remove .py e coloca em maiúsculas
            echo "📄 Processing file: $file → Stored as ${FILE_NAME}_CODE"

            FILE_CONTENT=$(awk '{printf "%s\\n", $0}' "$file" | paste -sd '' | sed 's/\\\\n/\\n/g' | sed 's/\n/\\n/g')

            # Se o arquivo estiver vazio, exibe um aviso mas continua o workflow
            if [[ -z "$FILE_CONTENT" ]]; then
              echo "⚠️ WARNING: File $file is empty!"
              continue  # Continua para o próximo arquivo, sem interromper o workflow
            fi

            # Salva cada código no ambiente do GitHub Actions com um nome dinâmico
            echo "${FILE_NAME}_CODE=${FILE_CONTENT}" >> $GITHUB_ENV
          done


          
      # - name: Debug - Check stored variables
      #   run: |          
      #     SUMMARIZE_CODE=$(awk '{printf "%s\\n", $0}' summarize.py | paste -sd '' | sed 's/\\\\n/\\n/g' | sed 's/\n/\\n/g')
      #     MULTIPLY_CODE=$(awk '{printf "%s\\n", $0}' multiply.py | paste -sd '' | sed 's/\\\\n/\\n/g' | sed 's/\n/\\n/g')

      #     # If variables are empty, set a default value
      #     if [[ -z "$SUMMARIZE_CODE" ]]; then echo "WARNING: File $file is empty!" else echo "File $file is not empty!"; fi
      #     if [[ -z "$MULTIPLY_CODE" ]]; then echo "WARNING: File $file is empty!" else echo "File $file is not empty!"; fi

          # echo "SUMMARIZE_CODE=${SUMMARIZE_CODE}" >> $GITHUB_ENV
          # echo "MULTIPLY_CODE=${MULTIPLY_CODE}" >> $GITHUB_ENV
        
      # - name: Debug - Check variables before sending
      #   run: |
      #     echo "SUMMARIZE_CODE: ${{ env.SUMMARIZE_CODE }}"
      #     echo "MULTIPLY_CODE: ${{ env.MULTIPLY_CODE }}"

      # - name: Send code to API
      #   env:
      #     API_KEY: ${{ secrets.API_KEY }}
      #     PYTHON_FILES: ${{ env.PYTHON_FILES }}
      #   run: |
      #     python - <<EOF
      #     import http.client
      #     import json
      #     import os

      #     conn = http.client.HTTPSConnection("eu-central-1.taktile-org.decide.taktile.com")
      #     api_key = os.getenv("API_KEY") # Import from  GitHub Secrets

      #     if not api_key:
      #         raise ValueError("Error: API_KEY is empty!")

      #     headers = {
      #         "X-Api-Key": api_key,
      #         "accept": "application/json",
      #         "Content-Type": "application/json"
      #     }

      #     # python_files = os.getenv("PYTHON_FILES", "").split()
      #     # for file_name in python_files:
      #     #     env_var = f"{file_name.replace('.py', '').upper()}_CODE"
      #     #     src_code = os.getenv(env_var)
          
      #     summarize_code = os.getenv("SUMMARIZE_CODE")
      #     multiply_code = os.getenv("MULTIPLY_CODE")

      #     if not summarize_code or summarize_code.strip() == "":
      #         raise ValueError("Error: SUMMARIZE_CODE is empty!")

      #     if not multiply_code or multiply_code.strip() == "":
      #         raise ValueError("Error: MULTIPLY_CODE is empty!")

      #     summarize_payload = json.dumps({
      #         "data": {
      #             "flow_id": "06457ab1-3367-43c3-9e6b-4dbaa88d1b1b",
      #             "node_id": "affc68e2-f4e7-40b2-a8e4-4f08ac9cc643",
      #             "src_code": summarize_code
      #         },
      #         "metadata": {
      #             "version": "v1.0",
      #             "entity_id": "string"
      #         },
      #         "control": {
      #             "execution_mode": "sync"
      #         }
      #     })

      #     multiply_payload = json.dumps({
      #         "data": {
      #             "flow_id": "06457ab1-3367-43c3-9e6b-4dbaa88d1b1b",
      #             "node_id": "affc68e2-f4e7-40b2-a8e4-4f08ac9cc123",
      #             "src_code": multiply_code
      #         },
      #         "metadata": {
      #             "version": "v1.0",
      #             "entity_id": "string"
      #         },
      #         "control": {
      #             "execution_mode": "sync"
      #         }
      #     })

      #     # Send SUMMARIZE_CODE
      #     conn.request("POST", "/run/api/v1/flows/patch-decision-graph/sandbox/decide", summarize_payload, headers)
      #     res = conn.getresponse()
      #     print("Summarize response:", res.status, res.read().decode("utf-8"))

      #     # Send MULTIPLY_CODE
      #     conn.request("POST", "/run/api/v1/flows/patch-decision-graph/sandbox/decide", multiply_payload, headers)
      #     res = conn.getresponse()
      #     print("Multiply response:", res.status, res.read().decode("utf-8"))
      #     EOF
